<!-- Autogenerated by mlir-tblgen; don't manually edit -->
### `numpy.builtin_ufunc_call` (::mlir::CANCER::Numpy::BuiltinUfuncCallOp)

A __call__ operation on a named/builtin ufunc


Syntax:

```
operation ::= `numpy.builtin_ufunc_call` `<` $qualified_name `>` `(` operands `)` attr-dict `:` functional-type(operands, results)
```

Simple ufunc call semantics for builtin ufuncs with none of the advanced
arguments specified.

Note that without the `out=` parameter, ufunc call operations (unlike
others like `at`) are defined purely in the value domain and do not alias.
As such, they operate on tensors, not ndarray.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`qualified_name` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`inputs` | tensor of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
`output` | tensor of any type values

### `numpy.copy_to_tensor` (::mlir::CANCER::Numpy::CopyToTensorOp)

Copies an ndarray, yielding a value-typed tensor.


Syntax:

```
operation ::= `numpy.copy_to_tensor` $source attr-dict `:` functional-type($source, $dest)
```

The semantics of this operation connote a copy of the data in the source
ndarray, producing a destination value that will have the value in the
ndarray at the point of the copy. Of course, downstream transformations
are free to rearrange things to elide the copy or otherwise eliminate the
need for it.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`source` | ndarray type

#### Results:

| Result | Description |
| :----: | ----------- |
`dest` | tensor of any type values

### `numpy.create_array_from_tensor` (::mlir::CANCER::Numpy::CreateArrayFromTensorOp)

Creates an ndarray from a tensor.


Syntax:

```
operation ::= `numpy.create_array_from_tensor` $source attr-dict `:` functional-type($source, $dest)
```

Creates a new ndarray that will contain the data of the given tensor.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`source` | tensor of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
`dest` | tensor of any type values or ndarray type

### `numpy.dot` (::mlir::CANCER::Numpy::DotOp)

Represents the `numpy.dot` operator


Syntax:

```
operation ::= `numpy.dot` operands attr-dict `:` functional-type(operands, $output)
```

See: https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`a` | tensor of any type values or ndarray type
`b` | tensor of any type values or ndarray type

#### Results:

| Result | Description |
| :----: | ----------- |
`output` | tensor of any type values or ndarray type

### `numpy.get_slice` (::mlir::CANCER::Numpy::GetSliceOp)

Gets a slice of an array


Syntax:

```
operation ::= `numpy.get_slice` operands attr-dict `:` functional-type(operands, $result)
```

This op encapsulates all forms of indexing into an array by taking a
variable number of `slice` arguments, each of which represents a single
entry in a generalized indexing-tuple. Once full type inference has
been performed, there should be sufficient static information to determine
the exact slice semantics solely by the signature of types of the `slice`
arguments.

Note that there is a more general form of this op that is generally
needed for AST extraction that takes a variable length `tuple` instead
of a static list of arguments. It is expected that during type refinement
most such uses should degenerate to this static variant.

Per numpy semantics, many forms of slice return a view instead of a copy,
and determining the exact form requires additional analysis.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`a` | tensor of any type values or ndarray type
`slice_elements` | types that are legal elements of a __getitem__ tuple operating on arrays

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | tensor of any type values or ndarray type

### `numpy.narrow` (::mlir::CANCER::Numpy::NarrowOp)

Narrows an array to a known type at boundaries.


Syntax:

```
operation ::= `numpy.narrow` $operand attr-dict `:` functional-type($operand, $result)
```

During tracing, specific data types are often unknown. This op generically
narrows from an unknown to a known data type at boundaries.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | tensor of any type values or ndarray type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | tensor of any type values or ndarray type

### `numpy.overwrite_array` (::mlir::CANCER::Numpy::OverwriteArrayOp)

Ovewrite the contents of array with a tensor.


Syntax:

```
operation ::= `numpy.overwrite_array` $tensor `overwrites` $array attr-dict `:` type($tensor) `,` type($array)
```

Replaces the contents of `array` with corresponding values from `tensor`.

Immediately after this op has completed, indexing `array` will result
in identical values as indexing into `tensor`. Of course, later ops
might mutate `array`, so this relationship need not hold for the entire
program.

This op has undefined behavior if the tensor and array have different
shapes or dtypes.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`tensor` | tensor of any type values
`array` | ndarray type

### `numpy.static_info_cast` (::mlir::CANCER::Numpy::StaticInfoCastOp)

Adds/removes static information from an array type.


Syntax:

```
operation ::= `numpy.static_info_cast` $operand attr-dict `:` type($operand) `to` type($result)
```

This op does not imply any runtime code. Semantically it is an identity
function.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | tensor of any type values or ndarray type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | tensor of any type values or ndarray type

### `numpy.tensor_static_info_cast` (::mlir::CANCER::Numpy::TensorStaticInfoCastOp)

Adds/removes static information from a tensor type.


Syntax:

```
operation ::= `numpy.tensor_static_info_cast` $operand attr-dict `:` type($operand) `to` type($result)
```

This op does not imply any runtime code. Semantically it is an identity
function.

Unlike `tensor.cast`, this op allows changing dtype, following the
rules of numpy arrays where no runtime code is implied. In particular,
`!numpy.any_dtype` is compatible with all other element types, but otherwise
the element types must be the same. An element type of `!numpy.any_dtype`
represents the absence of static knowledge of the dtype. It does not
itself represent a concrete runtime element type.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | tensor of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | tensor of any type values

### `numpy.transpose` (::mlir::CANCER::Numpy::TransposeOp)

Represents the `numpy.transpose` op with no permutation specified


Syntax:

```
operation ::= `numpy.transpose` operands attr-dict `:` functional-type(operands, $output)
```

This op is equivalent to calling `numpy.transpose(arr)`, which reverses
the axes of the array. It is separate from the explicit form because it
is not always possible to locallly infer an appropriate axis transform
at the point of declaration.

See: https://docs.scipy.org/doc/numpy/reference/generated/numpy.transpose.html

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`a` | tensor of any type values or ndarray type

#### Results:

| Result | Description |
| :----: | ----------- |
`output` | tensor of any type values or ndarray type

